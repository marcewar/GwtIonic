/*!
 * (C) Ionic http://ionicframework.com - MIT License
 * Built with http://stenciljs.com
 */
const{h:n}=window.Ionic;function t(n,t,e){return Math.max(n,Math.min(t,e))}function e(n){return void 0!==n&&null!==n}function r(n){return Array.isArray(n)}function o(n){return null!==n&&"object"==typeof n}function i(n){return"string"==typeof n}function u(n){return"number"==typeof n}function c(n){return void 0===n||null===n}function a(n,t){if(!n){const n="ASSERT: "+t;throw console.error(n),new Error(n)}}function l(n){const t=n.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]');if(t.length>0){const n=t[0];return n.focus(),n}return null}function s(n){return n.timeStamp||Date.now()}function f(n){if(n){const t=n.changedTouches;if(t&&t.length>0){const n=t[0];return{x:n.clientX,y:n.clientY}}if(void 0!==n.pageX)return{x:n.pageX,y:n.pageY}}return{x:0,y:0}}function d(n,t){let e=0,r=0;if(n){const t=n.changedTouches;if(t&&t.length>0){const n=t[0];e=n.clientX,r=n.clientY}else void 0!==n.pageX&&(e=n.pageX,r=n.pageY)}t.currentX=e,t.currentY=r}function p(n){const t=n.closest("ion-tabs");return t||(n.closest("ion-app,ion-page,.ion-page,page-inner")||function(n){return n.parentElement?n.parentElement:n.parentNode&&n.parentNode.host?n.parentNode.host:null}(n))}function m(n,t,e){return t?n>=window.innerWidth-e:n<=e}function g(n,t=!1){const e="rtl"===document.dir;switch(n){case"right":return!0;case"left":return!1;case"end":return!e;case"start":return e;default:return t?!e:e}}function h(n,t,e){return!t&&e||n&&t}function b(){return window}function w(){return document}function y(){return w().activeElement}function E(){const n=y();n&&n.blur&&n.blur()}const x=/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i;function T(){const n=y();return!(!(t=n)||"TEXTAREA"!==t.tagName&&"true"!==t.contentEditable&&("INPUT"!==t.tagName||x.test(t.type))||!n.parentElement)&&n.parentElement.querySelector(":focus")===n;var t}function X(n){return new Promise(t=>{n.onFinish(t),n.play()})}function v(n,t){return new Promise(e=>{n(()=>{if(!t)return e();Promise.resolve(t()).then((...n)=>{e(n)})})})}function A(n){return N(n,0)}function N(n,t){const e=n._original||n;return{_original:n,emit:function(n,t=0){let e;return(...r)=>{clearTimeout(e),e=setTimeout(n,t,...r)}}(e.emit.bind(e),t)}}export{X as playAnimationAsync,v as domControllerAsync,l as autoFocus,p as getPageElement,a as assert,e as isDef,c as isBlank,u as isNumber,s as now,A as deferEvent,r as isArray,i as isString,t as clamp,o as isObject,d as updateDetail,N as debounceEvent,f as pointerCoord,g as isRightSide,h as swipeShouldReset,E as focusOutActiveElement,w as getDocument,b as getWindow,T as hasFocusedTextInput,m as checkEdgeSide};